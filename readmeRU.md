Language: [EN](https://github.com/EvansTrein/iqProgers/blob/main/README.md) [RU](https://github.com/EvansTrein/iqProgers/blob/main/readmeRU.md)

# Это тестовое задание 
- Сделать REST API для финансовых операций с тремя ручками
  - Пополнение баланса пользователя.
  - Перевод денег от одного пользователя к другому.
  - Просмотр 10 последних операций пользователя.
- У пользователя есть баланс, а также список транзакций. 
- Не забывать использовать SQL транзакции!!!
- Авторизацию делать не нужно!
- Технологии: go, gin, pgx, postgreSQL, docker. 
- Для миграций использовать goose, выполнять конфигурацию через ENV. 
- К решению также приложить файл .env.example.
- Сделать запуск приложения через docker-compose при помощи Makefile. При вызове команды make run должны подняться контейнеры, выполниться миграции и запуститься сервер на порту 8080.
- Для сложных запросов можно использовать query-builder. 
- Также нужно написать unit-тесты для сервисного слоя приложения
- В приложении использовать подход **clean architecture**
(handler -> service -> repository).

Можно писать с уточняющими вопросами по задаче.
После выполнения прислать ссылку на github с выполненным тестовым заданием.
В случае успешного выполнения запланируем собеседование. Времени на выполнение дали 6 дней (я сделал за 3). 

# Как запустить?
Для Docker:

- Клонируйте или скачайте репозиторий - введите `make run-docker-compose`
- Если make вы не пользуетесь - введите `docker compose --env-file configForDocker.env up --build -d`

Для локального запуска:
 - Клонируйте или скачайте репозиторий
 - Для запуска **нужна БД (PostgreSQL) и миграции**, введите `make migrate`, без make нужно будет вручную передать путь к БД как флаг (см. пример в .env файлах).
 - введите `make run`
 - Если make вы не пользуетесь - введите `go run cmd/main.go -config ./configLocal.env`

Пользователи были созданы в миграции. Их 5 штук, id от 1 до 5. Можете тестировать API.

## Про уточняющие вопросы
В общении, я упомянул, что не пользовался `goose`, но пользовался `migrate`. Мне разрешили использовать `migrate`.

Также, в ходе беседы, выяснилось, что использовать query-builder не обязательно. Цитата: <u>"Мы приветствуем написание 'сырых' запросов, так что можете не использовать query builder"</u>.

Беседа, немного, заятнулась, я уточнял детали. Отвечали все развернуто! А итог - Цитата: <u>"если есть желание сделать доп условия, подумайте про идемпотентность в вашем API, при работе с платежными транзакциями.
Также, какие варианты есть по конкурентному списанию денег с баланса, если параллельно будет работать несколько транзакций SQL.
Как вы будете хранить деньги, какой тип данных использовать"</u>

Сначала, я не так понял про **идемпотентность API** и **какой тип данных использовать** для денег. Ответы:
 - "Может быть так что на стороне клиента был сетевой сбой и он повторил запрос на списание 500 рублей. Должно списаться именно 500, а не 1000. Нужно использовать ключ идемпотентности."
 - "Храните деньги в bigint 500 рублей это 50000 в инт вместе с копейками."

В общем, при беседе, я понял, что тут будут смотреть, с равной значимостью на то, как пишутся SQL-запросы и ACID, а не только на сам Golang. 

## Выполнение
Пользователи создаются через миграцию.

Баланс тут хранится в BIGINT. Последние 2 знака это копейки.
 
Например: 
- 1000 в БД хранится как 1000<a>00</a>, а в приложении это float64 1000.00.
- преобразования float64 в BIGINT и наоборот, проходят на стороне БД. Мне удобнее было бы сделать в приложении, чтобы в БД отправлять уже готовые числа, но специально сделал так для показа навыков SQL. 

Для идемпотентности - в таблице с транзакциями есть `idempotency_key`. Если приходит запрос, но ключ уже есть, то возвращается `http код 200` и транзакция, содержащая этот ключ.